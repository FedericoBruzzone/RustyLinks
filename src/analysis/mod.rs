use crate::CliArgs;

use std::{cell::Cell, time::Duration};

// use rustc_middle::mir::BasicBlock;
// use rustc_index::Idx;
use rustc_middle::mir;
use rustc_middle::mir::visit::Visitor;
use rustc_middle::ty;

pub struct Analyzer<'tcx> {
    tcx: ty::TyCtxt<'tcx>,
    cli_args: CliArgs,
}

impl<'tcx> Analyzer<'tcx> {
    pub fn new(tcx: ty::TyCtxt<'tcx>, cli_args: CliArgs) -> Self {
        Self { tcx, cli_args }
    }

    fn pre_process_cli_args(&self) {
        log::debug!("Pre-processing CLI arguments");
        if self.cli_args.print_crate {
            log::debug!("Printing the crate");
            let resolver_and_krate = self.tcx.resolver_for_lowering().borrow();
            let krate = &*resolver_and_krate.1;
            println!("{:#?}", krate);
        }

        // In case of "optimized" MIR, in the `config` callback we do not set the `mir_opt_level` to 0.
        if self.cli_args.print_mir || self.cli_args.print_unoptimized_mir {
            log::debug!("Printing the MIR");
            mir::write_mir_pretty(self.tcx, None, &mut std::io::stdout())
                .expect("write_mir_pretty failed");
        }
    }

    fn post_process_cli_args(&self) {
        log::debug!("Post-processing CLI arguments");
    }

    fn run_analysis(&mut self, name: &str, f: impl FnOnce(&mut Self)) {
        log::debug!("Running analysis: {}", name);
        f(self);
        log::debug!("Finished analysis: {}", name);
    }

    pub fn run(&mut self) {
        self.pre_process_cli_args();
        self.run_analysis("FirstAnalysis", |analyzer| {
            FirstAnalysis::new(analyzer).run();
        });
        self.post_process_cli_args();
    }
}

struct FirstAnalysis<'tcx, 'a> {
    analyzer: &'a mut Analyzer<'tcx>,
    elapsed: Cell<Option<Duration>>,
}

impl<'tcx, 'a> FirstAnalysis<'tcx, 'a> {
    pub fn new(analyzer: &'a mut Analyzer<'tcx>) -> Self {
        Self {
            analyzer,
            elapsed: Cell::new(None),
        }
    }

    fn visitor(&self) {
        let visitor = &mut FirstVisitor;

        // We do not need to call `mir_keys` (self.analyzer.tcx.mir_keys(()))
        // because it returns also the enum and struct constructors
        // automatically generated by the compiler.
        //
        // For example, for the following code
        // ```no_run
        // struct MyStruct(i32);
        // enum MyEnum { Variant(i32) }
        // ```
        // the `mir_keys` returns the following local_def_ids
        // ```no_run
        // MyStruct::{constructor#0})
        // MyEnum::Variant::{constructor#0})
        // ```
        for local_def_id in self.analyzer.tcx.hir().body_owners() {
            // Visit the body of the `local_def_id`
            visitor.start_visit(
                local_def_id,
                self.analyzer
                    .tcx
                    .instance_mir(ty::InstanceKind::Item(local_def_id.to_def_id())),
            );

            // TODO: Check if the body has some promoted MIR.
            // It is not clear if analyzing the promoted MIR is necessary.
            let _promoted_mir = self.analyzer.tcx.promoted_mir(local_def_id.to_def_id());

            // let stmts = &body.basic_blocks[BasicBlock::new(0)].statements;
            // let terminator = &body.basic_blocks[BasicBlock::new(0)].terminator;
            // if !stmts.is_empty() {
            //     let first = &stmts[0].kind;
            //     match first {
            //         mir::StatementKind::Assign(bbox) => {
            //             // let place = &bbox.0;
            //             let rvalue = &bbox.1;
            //             match rvalue {
            //                 mir::Rvalue::Use(operand) => {
            //                     let op = &operand;
            //                     match op {
            //                         mir::Operand::Copy(place) => {
            //                             println!("{:#?}", place);
            //                         }
            //                         mir::Operand::Move(place) => {
            //                             println!("{:#?}", place);
            //                         }
            //                         mir::Operand::Constant(constant) => {
            //                             println!("hello {:#?}", constant);
            //                         }
            //                     }
            //                 }
            //                 _ => println!(),
            //             }
            //         }
            //         _ => println!(),
            //     }
            // }

            // if let Some(t) = terminator {
            //     let kind = &t.kind;
            //     match kind {
            //         mir::TerminatorKind::Call {
            //             func,
            //             args,
            //             destination,
            //             ..
            //         } => {
            //             println!("{:#?}", func);
            //             println!("{:#?}", args);
            //             println!("{:#?}", destination);
            //         }
            //         _ => println!(),
            //     }
            // }
            // println!();

            // println!("{:#?}\n", body);
            // println!("{:#?}\n", promoted_mir);
            // println!("{:#?}\n", body.local_decls);
            // println!("{:#?}\n", body.basic_blocks);
        }
    }

    pub fn run(&self) {
        let start_time = std::time::Instant::now();
        self.visitor();
        let elapsed = start_time.elapsed();
        self.elapsed.set(Some(elapsed));
    }
}

struct FirstVisitor;

impl FirstVisitor {
    fn start_visit(&mut self, local_def_id: rustc_span::def_id::LocalDefId, body: &mir::Body<'_>) {
        log::debug!("Visiting the local_def_id: {:?}", local_def_id);
        // TODO: push onto the stack the local_def_id
        self.visit_body(body);
    }
}

impl<'tcx> Visitor<'tcx> for FirstVisitor {
    fn visit_body(&mut self, body: &mir::Body<'tcx>) {
        self.super_body(body);
    }

    // fn visit_local_decl(&mut self, local: mir::Local, local_decl: &mir::LocalDecl<'_>) {}

    // We can avoid to visit the `ty` because we are not interested in the types.
    // fn visit_ty(&mut self, ty: ty::Ty<'tcx>, context: mir::visit::TyContext) {}
}
