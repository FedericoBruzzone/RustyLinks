pub mod rl_graph;
pub mod rl_petgraph;
pub mod rl_visitor;

use super::Analyzer;
use rl_graph::{RLEdge, RLGraph, RLIndex, RLNode};
use rl_visitor::RLVisitor;

use rustc_middle::ty;
use std::{cell::Cell, time::Duration};

pub struct RLAnalysis<'tcx, 'a, G>
where
    G: RLGraph<Node = RLNode, Edge = RLEdge, Index = RLIndex> + Default + Clone,
{
    analyzer: &'a Analyzer<'tcx, G>,
    elapsed: Cell<Option<Duration>>,
}

impl<'tcx, 'a, G> RLAnalysis<'tcx, 'a, G>
where
    G: RLGraph<Node = RLNode, Edge = RLEdge, Index = RLIndex> + Default + Clone,
{
    pub fn new(analyzer: &'a Analyzer<'tcx, G>) -> Self {
        Self {
            analyzer,
            elapsed: Cell::new(None),
        }
    }

    fn visitor(&self) {
        let visitor = &mut RLVisitor::new(self.analyzer);

        // We do not need to call `mir_keys` (self.analyzer.tcx.mir_keys(()))
        // because it returns also the enum and struct constructors
        // automatically generated by the compiler.
        //
        // For example, for the following code
        // ```no_run
        // struct MyStruct(i32);
        // enum MyEnum { Variant(i32) }
        // ```
        // the `mir_keys` returns the following local_def_ids
        // ```no_run
        // MyStruct::{constructor#0})
        // MyEnum::Variant::{constructor#0})
        // ```
        for local_def_id in self.analyzer.tcx.hir().body_owners() {
            // Visit the body of the `local_def_id`
            visitor.visit_local_def_id(
                local_def_id,
                self.analyzer
                    .tcx
                    .instance_mir(ty::InstanceKind::Item(local_def_id.to_def_id())),
            );

            // TODO: Check if the body has some promoted MIR.
            // It is not clear if analyzing the promoted MIR is necessary.
            let _promoted_mir = self.analyzer.tcx.promoted_mir(local_def_id.to_def_id());
        }

        self.analyzer.rl_graph.set(visitor.rl_graph().clone());
    }

    pub fn run(&self) {
        let start_time = std::time::Instant::now();
        self.visitor();
        let elapsed = start_time.elapsed();
        self.elapsed.set(Some(elapsed));
    }
}
